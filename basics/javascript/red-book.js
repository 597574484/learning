/**
 * 值与引用
 *
 * 
 * 变量间复制时，复制基本类型值和引用类型值存在不同。
 * 基本类型 (Null, Undefined, Number, Boolean, String)，复制时开辟新空间储存值复制源的值。
 *         两者独立。更改一个，另一个不受影响。
 * 复杂类型(Object, Map, Set) 赋值时传递引用(指向目标的指针)。所以两者都是引用。指向同一个地方。
 *         所以改变一个，另一个 必然改变。 
 *-------------------------------------------------------------------------------------------------
 *
 * 当被当做函数参数传递时，只有值传递，即将源内容拷贝一份(基本类型拷贝值，复杂类型拷贝引用)，传递给形参。
 * 
 * ！！！！只有值传递！！！！
 * 
 * 而当复杂类型被传递进函数，因为内部改变而导致外部改变，所以被#错误#的认为是引用传递，并不是。
 * 
 * 解释 :   1.若#基本类型#传递进函数，内部修改而导致外部变化的话，才是引用传递。
 * 			2.#复杂类型#传递进函数，内部修改而导致外部变化，不能用来判断值传递还是引用传递。
 * 			3.	function setName(obj){
 * 					obj.name = 'old name';     Ⅰ
 * 				 	obj = new Object();		   Ⅱ	
 * 				  	obj.name = 'new name';     Ⅲ
 * 			    }
 * 			    var person = {};
 * 		 	   setName(person); //person.name === 'old name'; √
 *
 * 				//值传递结果 : 'old name'，因为 Ⅱ中，obj被赋为新对象，obj为引用，
 * 				//             此时则被指向另一个对象，对新对象的操作对原对象没卵用。 
 * 				//引用传递  : 如果是引用传递的话，obj所代表的原对象的地址当内部内容被 'new Object' 代替时.
 * 				//            对obj的操作则应该等同于对外部的person操作。
 *
 * 结论 ：传参只有值传递，而对于复杂对象的值传递和引用传递，很明显的区别就是对 '=' (赋值号)的处理。
 * -------------------------------------------------------------------------------------------------
 * -------------------------------------------------------------------------------------------------
 *
 * 
 */